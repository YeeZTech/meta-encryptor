import fs from 'fs';
import path from 'path';
import { UnsealerBrowser } from '../src/browser/UnsealerBrowser.js';

describe('Browser Unsealer compatibility', () => {
  it('should decrypt to original content (single chunk input)', async () => {
    // read fixture produced by Node generator script
    const repoRoot = path.resolve(new URL(import.meta.url).pathname, '..', '..');
    const fixturePath = path.join(repoRoot, 'test', 'fixtures', 'browser-unsealer-fixture-small.json');
    const fixture = JSON.parse(fs.readFileSync(fixturePath, 'utf8'));
    const streamBuf = fs.readFileSync(fixture.sealed_path);

    const un = new UnsealerBrowser({ privateKeyHex: fixture.private_key_hex });
    const chunks = [];
    // feed header and content in two parts to simulate streaming
    // header size is fixed inside UnsealerBrowser; split at first 512 bytes to simulate
    const splitAt = Math.min(512, streamBuf.length);
    chunks.push(...(await un.pushChunk(streamBuf.subarray(0, splitAt))));
    chunks.push(...(await un.pushChunk(streamBuf.subarray(splitAt))));
    const merged = Buffer.concat(chunks.map(b=>Buffer.from(b)));
    const plain = fs.readFileSync(fixture.plain_path);
    expect(merged.equals(Buffer.from(plain))).toBe(true);
  }, 20000);

  it('should decrypt multiple inputs batched', async () => {
    // use fixture generated by Node helper
    const repoRoot = path.resolve(new URL(import.meta.url).pathname, '..', '..');
    const fixturePath = path.join(repoRoot, 'test', 'fixtures', 'browser-unsealer-fixture-small.json');
    const fixture = JSON.parse(fs.readFileSync(fixturePath, 'utf8'));
    const streamBuf = fs.readFileSync(fixture.sealed_path);

    const un = new UnsealerBrowser({ privateKeyHex: fixture.private_key_hex });
    const outputs = [];
    // feed random chunk sizes
    let offset = 0; const sizes = [13, 7, 1024, 5, 256];
    let idx=0; while(offset < streamBuf.length){
      const n = Math.min(streamBuf.length - offset, sizes[idx % sizes.length]);
      const part = streamBuf.subarray(offset, offset+n);
      const outs = await un.pushChunk(part);
      outputs.push(...outs);
      offset+=n; idx++;
    }
    const merged = Buffer.concat(outputs.map(b=>Buffer.from(b)));
    const plain = fs.readFileSync(fixture.plain_path);
    expect(merged.equals(Buffer.from(plain))).toBe(true);
  }, 20000);
});
